<script>
  let startTime, elapsedTime = 0, timerInterval, isRunning = false;

  // Obt√©m taskId passado via query string: ?taskId=XXXX
  const urlParams = new URLSearchParams(window.location.search);
  const taskId = urlParams.get('taskId');

  if (!taskId) {
    console.error("Erro: taskId n√£o fornecido na URL");
  }

  const API_URL = `https://x8ki-letl-twmt.n7.xano.io/api:MmzSqGu8/fluxo_de_trabalho/${taskId}`;

  function formatTime(ms) {
    const total = Math.max(0, Math.floor(ms / 1000));
    const h = String(Math.floor(total / 3600)).padStart(2, '0');
    const m = String(Math.floor((total % 3600) / 60)).padStart(2, '0');
    const s = String(total % 60).padStart(2, '0');
    return `${h}:${m}:${s}`;
  }

  function updateDisplay() {
    const now = Date.now();
    const diff = now - startTime + elapsedTime;
    document.getElementById("timerText").textContent = formatTime(diff);
  }

  async function toggleTimer() {
    const btn = document.getElementById("toggleBtn");

    if (!taskId) {
      alert("taskId n√£o encontrado na URL.");
      return;
    }

    if (!isRunning) {
      // ‚ñ∂Ô∏è INICIAR / RETOMAR
      startTime = Date.now();
      timerInterval = setInterval(updateDisplay, 1000);
      isRunning = true;
      btn.textContent = "‚è∏Ô∏è";

      try {
        await fetch(API_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            Last_Started_At: new Date().toISOString(),
            Timer_Running: true
          })
        });
      } catch (e) {
        console.error("Erro ao iniciar timer:", e);
      }

    } else {
      // ‚è∏Ô∏è PAUSAR
      clearInterval(timerInterval);
      isRunning = false;
      btn.textContent = "‚ñ∂Ô∏è";

      const now = Date.now();
      const diff = now - startTime;
      elapsedTime += diff;

      const totalSeconds = Math.floor(elapsedTime / 1000);
      document.getElementById("timerText").textContent = formatTime(elapsedTime);

      try {
        await fetch(API_URL, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            Tempo_Total: totalSeconds,     // salva acumulado (s)
            Timer_Running: false
          })
        });
      } catch (e) {
        console.error("Erro ao pausar timer:", e);
      }
    }
  }

  // üîÑ Carrega tempo salvo e auto-retoma se estava rodando
  async function bootstrap() {
    if (!taskId) return;

    try {
      const res = await fetch(API_URL, { method: "GET" });
      const data = await res.json();

      const persistedSeconds = Number(data?.Tempo_Total || 0);
      const wasRunning = Boolean(data?.Timer_Running);
      const lastStartedISO = data?.Last_Started_At;

      // 1) Preenche o tempo acumulado salvo
      elapsedTime = persistedSeconds * 1000;
      document.getElementById("timerText").textContent = formatTime(elapsedTime);

      // 2) Se estava rodando antes do refresh, continua de onde parou
      if (wasRunning && lastStartedISO) {
        const lastStartMs = Date.parse(lastStartedISO);
        if (!Number.isNaN(lastStartMs)) {
          // considera o tempo que passou desde o √∫ltimo start
          const carryMs = Date.now() - lastStartMs;
          // inicia interval a partir de agora, somando carry
          startTime = Date.now() - carryMs;
          isRunning = true;
          document.getElementById("toggleBtn").textContent = "‚è∏Ô∏è";
          timerInterval = setInterval(updateDisplay, 1000);
          // pinta j√° com o acumulado + carry
          document.getElementById("timerText").textContent = formatTime(elapsedTime + carryMs);
        }
      }
    } catch (err) {
      console.error("Erro ao carregar estado:", err);
    }
  }

  window.addEventListener("load", bootstrap);
</script>
